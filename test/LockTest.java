/*
 * Copyright Â© 2017 CMCC and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */
package com.coreos.jetcd.concurrency;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.testng.annotations.AfterTest;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;
import org.testng.asserts.Assertion;

import com.coreos.jetcd.Client;
import com.coreos.jetcd.ClientBuilder;
import com.coreos.jetcd.Watch.Watcher;
import com.coreos.jetcd.concurrency.Mutex;
import com.coreos.jetcd.concurrency.Session;
import com.coreos.jetcd.concurrency.UMutex;
import com.coreos.jetcd.data.ByteSequence;
import com.coreos.jetcd.internal.impl.TestConstants;
import com.coreos.jetcd.kv.GetResponse;
import com.coreos.jetcd.kv.PutResponse;
import com.coreos.jetcd.options.GetOption;
import com.coreos.jetcd.options.WatchOption;
import com.coreos.jetcd.watch.WatchEvent;
import com.coreos.jetcd.watch.WatchResponse;
import com.coreos.jetcd.watch.WatchEvent.EventType;

public class LockTest {
  private static final String path = "root/dirA/dirB";
  private static final ByteSequence PATH = ByteSequence.fromString("root/dirA/dirB");

  private Assertion test;
  private Client client;

  @BeforeTest
  public void setUp() throws Exception {
    test = new Assertion();
    client = ClientBuilder.newBuilder().setEndpoints(TestConstants.endpoints).build();
  }
  
  @AfterTest
  public void tearDown() {
    this.client.close();
  }
  
  @Test
  public void testUlock() throws Exception{
    Session session = Session.newBuilder().setClient(client).build();
    Mutex m = new UMutex(path, session);
    boolean lockResult = m.lock();
    test.assertTrue(lockResult);
    GetResponse getRes = client.getKVClient().get(ByteSequence.fromString(path),
        GetOption.newBuilder().withPrefix(ByteSequence.fromString(path)).build()).get();
    
    test.assertTrue(getRes.getKvs().size() == 1);
    
    test.assertEquals(getRes.getKvs().get(0).getKey().toStringUtf8(),
        path + "/update/" + session.getLease());
    
    m.unlock();
    getRes = client.getKVClient().get(ByteSequence.fromString(path),
        GetOption.newBuilder().withPrefix(ByteSequence.fromString(path)).build()).get();
    test.assertTrue(getRes.getKvs().size() == 0);
    
  }
  
  @Test
  public void test2Ulocks() throws Exception{
    Session firstOwnerSession = Session.newBuilder().setClient(client).build();
    Mutex firstOwnerMutex = new UMutex(path, firstOwnerSession);
    
    /*lauch the first thread to lock the firstowner*/
    Thread firstOwnerThread = new Thread(() -> {
      try {
        firstOwnerMutex.lock();
      } catch (Exception e) {
        e.printStackTrace();
      }
    });
    firstOwnerThread.start();
    
    Session secondOwnerSession = Session.newBuilder().setClient(client).build();
    Mutex secondOwnerMutex = new UMutex(path, secondOwnerSession);
    /*lauch the second thread to lock the secondowner, which will be blocked*/
    Thread secondOwnerThread = new Thread(() -> {
      try {
        firstOwnerThread.join();
        secondOwnerMutex.lock();
      } catch (Exception e) {
        e.printStackTrace();
      }
    });
    secondOwnerThread.start();
    
   /*verify the 2 PUT events generated by the 2 lock operations */
   Watcher watcher =  client.getWatchClient().watch(PATH, 
        WatchOption.newBuilder().withPrefix(PATH).withRevision(firstOwnerMutex.getRev()).build());
   ExecutorService executor = Executors.newSingleThreadExecutor();
   Future<List<WatchEvent>> future = executor.submit(() -> {
     int count = 0;
     List<WatchEvent> events = new ArrayList();
     while (count < 2) {
       WatchResponse wchRes = watcher.listen();
       count += wchRes.getEvents().size();
       events.addAll(wchRes.getEvents());
     }
     return events;
   });
   List<WatchEvent> eventList = future.get(1, TimeUnit.SECONDS);  
   test.assertEquals(eventList.size(), 2);
   test.assertEquals(eventList.get(0).getEventType(),EventType.PUT);
   test.assertEquals(eventList.get(1).getEventType(),EventType.PUT);

   /*unlock the first owner*/
   firstOwnerMutex.unlock();
   /*verify the DELETE event of the first owner*/
   eventList = executor.submit(() -> {
     WatchResponse wchRes = watcher.listen();
     return wchRes.getEvents();
   }).get(1, TimeUnit.SECONDS);
   test.assertEquals(eventList.size(), 1);
   test.assertEquals(eventList.get(0).getEventType(),EventType.DELETE);
   
   /*verify that the second lock has returned*/ 
   if (secondOwnerThread.isAlive()) {
     Thread.sleep(1000);
     if (secondOwnerThread.isAlive()) {
       throw new TimeoutException();
     }
   }
   test.assertEquals(secondOwnerMutex.isOwner(), true);
   long lease = client.getKVClient().get(PATH,GetOption.newBuilder().withPrefix(PATH).build())
       .get().getKvs().get(0).getLease();
   test.assertEquals(lease, secondOwnerSession.getLease());
   secondOwnerMutex.unlock();
   /*verify the DELETE event of the second owner*/
   eventList = executor.submit(() -> {
     WatchResponse wchRes = watcher.listen();
     return wchRes.getEvents();
   }).get(1, TimeUnit.SECONDS);
   test.assertEquals(eventList.size(), 1);
   test.assertEquals(eventList.get(0).getEventType(),EventType.DELETE);
   test.assertEquals(eventList.get(0).getKeyValue().getLease(), secondOwnerSession.getLease());
  }
}
