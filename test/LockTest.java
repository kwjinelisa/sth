/*
 * Copyright Â© 2017 CMCC and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */
package com.coreos.jetcd.concurrency;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.testng.annotations.AfterTest;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;
import org.testng.asserts.Assertion;

import com.coreos.jetcd.Client;
import com.coreos.jetcd.ClientBuilder;
import com.coreos.jetcd.Watch.Watcher;
import com.coreos.jetcd.concurrency.Mutex;
import com.coreos.jetcd.concurrency.Session;
import com.coreos.jetcd.concurrency.UMutex;
import com.coreos.jetcd.data.ByteSequence;
import com.coreos.jetcd.exception.EtcdException;
import com.coreos.jetcd.internal.impl.TestConstants;
import com.coreos.jetcd.kv.GetResponse;
import com.coreos.jetcd.kv.PutResponse;
import com.coreos.jetcd.options.GetOption;
import com.coreos.jetcd.options.WatchOption;
import com.coreos.jetcd.watch.WatchEvent;
import com.coreos.jetcd.watch.WatchResponse;
import com.coreos.jetcd.watch.WatchEvent.EventType;

public class LockTest {
  private static final String path = "root/dirA/dirB";
  private static final ByteSequence PATH = ByteSequence.fromString("root/dirA/dirB");

  private Assertion test;
  private Client client;

  @BeforeTest
  public void setUp() throws Exception {
    test = new Assertion();
    client = ClientBuilder.newBuilder().setEndpoints(TestConstants.endpoints).build();
  }
  
  @AfterTest
  public void tearDown() {
    this.client.close();
  }
  
  @Test
  public void test2Ulocks() throws Exception{
    Session firstOwnerSession = Session.newBuilder().setClient(client).build();
    Mutex firstOwnerMutex = new UMutex(path, firstOwnerSession);
    /*launch the first thread to lock the firstowner*/
    Thread firstOwnerThread = newLockThread(firstOwnerMutex, true);
    firstOwnerThread.start();
    
    Session secondOwnerSession = Session.newBuilder().setClient(client).build();
    Mutex secondOwnerMutex = new UMutex(path, secondOwnerSession);
    /*launch the second thread to lock the second owner, 
    which will be blocked until the unlocking of the first owner*/
    firstOwnerThread.join();
    Thread secondOwnerThread = newLockThread(secondOwnerMutex, true);
    secondOwnerThread.start();
    
   /*verify the 2 PUT events generated by the 2 lock operations */
   Watcher watcher =  client.getWatchClient().watch(PATH, 
        WatchOption.newBuilder().withPrefix(PATH).withRevision(firstOwnerMutex.getRev()).build());
   ExecutorService executor = Executors.newSingleThreadExecutor();
   Future<List<WatchEvent>> future = executor.submit(() -> {
     int count = 0;
     List<WatchEvent> events = new ArrayList();
     while (count < 2) {
       WatchResponse wchRes = watcher.listen();
       count += wchRes.getEvents().size();
       events.addAll(wchRes.getEvents());
     }
     return events;
   });
   List<WatchEvent> eventList = future.get(1, TimeUnit.SECONDS);  
   test.assertEquals(eventList.size(), 2);
   test.assertEquals(eventList.get(0).getEventType(),EventType.PUT);
   test.assertEquals(eventList.get(1).getEventType(),EventType.PUT);

   /*unlock the first owner*/
   firstOwnerMutex.unlock();
   /*verify the DELETE event of the first owner*/
   eventList = executor.submit(() -> {
     WatchResponse wchRes = watcher.listen();
     return wchRes.getEvents();
   }).get(1, TimeUnit.SECONDS);
   test.assertEquals(eventList.size(), 1);
   test.assertEquals(eventList.get(0).getEventType(),EventType.DELETE);
   
   /*verify that the second lock has returned*/ 
   checkThreadReturned(secondOwnerThread);
   /*verify that the second lock is now the owner*/
   test.assertTrue(secondOwnerMutex.isOwner());
   /*unlock the second owner*/
   secondOwnerMutex.unlock();
   
   /*verify the DELETE event of the second owner*/
   eventList = executor.submit(() -> {
     WatchResponse wchRes = watcher.listen();
     return wchRes.getEvents();
   }).get(1, TimeUnit.SECONDS);
   
   test.assertEquals(eventList.size(), 1);
   test.assertEquals(eventList.get(0).getEventType(),EventType.DELETE);
   //test.assertEquals(secondOwnerSession.getLease(),eventList.get(0).getKeyValue().getLease());
   //test.assertEquals(secondOwnerSession.getLease(), 0l);
   //test.assertEquals(eventList.get(0).getKeyValue().getLease(), secondOwnerSession.getLease());
  }
  
  @Test
  /*testcase where the waiter prior to the acquirer expires before the current holder.*/
  public void test3Ulocks() throws Exception {

    Mutex firstOwnerMutex = newMutexfromClient(client, path);
    Mutex victimMutex = newMutexfromClient(client, path);
    Mutex secondOwnerMutex = newMutexfromClient(client, path);
    
    /*launch a new thread to lock the first owner*/
    Thread firstOwnerThread = newLockThread(firstOwnerMutex, true);
    firstOwnerThread.start();
    
    /*launch a new thread to lock the victim, which will be blocked*/
    firstOwnerThread.join();
    Thread victimThread = newLockThread(victimMutex, true);
    victimThread.start(); 
    
    Watcher watcher =  newWatcherwithPfxRev(PATH, firstOwnerMutex.getRev());
    
    ExecutorService executor = Executors.newSingleThreadExecutor();
    
    List<WatchEvent> eventList = getEventsFromWatcher(watcher, executor, 2);
    test.assertEquals(eventList.size(), 2);
    test.assertEquals(eventList.get(0).getEventType(),EventType.PUT);
    test.assertEquals(eventList.get(1).getEventType(),EventType.PUT);
    
    
    /*launch a new thread to lock the secondowner, which will be blocked*/
    Thread secondOwnerThread = newLockThread(secondOwnerMutex, true);
    secondOwnerThread.start(); 
    eventList = getEventsFromWatcher(watcher, executor, 1);
    test.assertEquals(eventList.size(), 1);
    test.assertEquals(eventList.get(0).getEventType(),EventType.PUT);
    
    /*simulate losing the client that's next in line to acquire the lock*/
    victimMutex.getSession().close();
    /*verify the victim mutex is deleted*/
    eventList = getEventsFromWatcher(watcher, executor, 1);
    test.assertEquals(eventList.size(), 1);
    test.assertEquals(eventList.get(0).getEventType(),EventType.DELETE);
    /*verify that the second owner has not yet acquired the lock*/
    test.assertEquals(secondOwnerThread.isAlive(), true);
    test.assertTrue(!secondOwnerMutex.isOwner());
    
    /*unlock the first owner*/
    firstOwnerMutex.unlock();
    /*verify that the 2nd owner lock has returned*/
    checkThreadReturned(secondOwnerThread);
    /*verify that the second lock is now the owner*/
    test.assertTrue(secondOwnerMutex.isOwner());
    
    /*verify that the victim thread has terminated without acquiring the lock*/
    victimThread.join(1000);
    test.assertTrue(!victimMutex.isOwner());
      
    
  }
  
  
  private List<WatchEvent> getEventsFromWatcher(Watcher watcher, 
      ExecutorService executor, int numEvents) throws Exception {
    Future<List<WatchEvent>> future = executor.submit(() -> {
      int count = 0;
      List<WatchEvent> events = new ArrayList();
      while (count < numEvents) {
        WatchResponse wchRes = watcher.listen();
        count += wchRes.getEvents().size();
        events.addAll(wchRes.getEvents());
      }
      return events;
    });
    return future.get(1, TimeUnit.SECONDS);
  }
  
  private Watcher newWatcherwithPfxRev(ByteSequence prefix, long revision) {
    return client.getWatchClient().watch(prefix, 
        WatchOption.newBuilder().withPrefix(prefix).withRevision(revision).build());
  }
  
  private Mutex newMutexfromClient(Client client, String prefix)
      throws InterruptedException, ExecutionException{ 
    Session session = Session.newBuilder().setClient(client).build();
    return new UMutex(prefix, session);
  }
  
  private Thread newLockThread(Mutex m, boolean toSucceed) {
    return new Thread(() -> {
      try {
        test.assertEquals(m.lock(), toSucceed);
      } catch (EtcdException e) {
        System.out.println(e.getMessage());
      } catch (Exception e) {
        e.printStackTrace();
      }
    });
  }
  
  private void checkThreadReturned(Thread thread) throws Exception{
    if (thread.isAlive()) {
      Thread.sleep(1000);
      if (thread.isAlive()) {
        throw new TimeoutException();
      }
    }
  }
}
